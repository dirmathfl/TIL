# Basic

> 도커에 대해 알아보기 전에 기존의 LXC(Linux Container)와 달리 많은 사람들이 도커를 사용하게 되고, 지금도 컨테이너 기반의 시스템 구축에 애용되는지 알아보기 위해 배경지식을 알아보고자 한다.

  

# Container

 컨테이너는 **운영체제 수준의 가상화(Operating System level virtualization)**을 통해 각 컨테이너 별로 독립적으로 실행될 수 있는 환경을 제공한다. 도커가 등장하기 전에는  LXC(Linux Container)가 유명하였다. 초기에 도커는 LXC를 런타임으로 사용하는 방식을 채택하였다. 시간이 지남에 따라, 업그레이드 하면서 LXC 없이도 동작할 수 있는 버전을 제공하였다.

   

 VM Ware와 Virtual Box는 컨테이너와 달리 Hypervisor를 통해 Gest OS를 제공하는 한다. 이는 호스트 OS와 다른 OS를 사용하는 환경에서는 적합하지만, 이외에는 상대적으로 컨테이너보다 오버헤드가 크다는 단점을 가지고 있다. 상대적으로 컨테이너를 실행 - 종료하는 오버헤드가 상당히 적은 컨테이너는 Life time이 짧은 프로그램이나 테스트 환경 구축을 위해 보다 적합하다.

  

# System Resource Isolation

> 도커 컨테이너와 LXC는 어떤 방식으로 컨테이너 별로 독립적은 공간과 시스템 자원을 할당하는지를 이해하는 것은 중요하다. 현재 도커 컨테이너는 리눅스 커널의 2가지 기능을 활용하여 컨테이너 별 분리된 작업 공간을 제공하고 있다.

  

  ## 1. Cgroups

 컨테이너 별로 자원을 적절하게 할당하기 위해 `Cgroups`를 이용한다. 이는 Control Cgroups의 줄임말로, CPU, Memory, I/O, Network 등 시스템 자원을 지정한 Cgroup에 할당 할 수 있다.

## 2. Namespaces

 각 컨테이너의 독립적인 공간을 제공하기 위해서는 로컬 호스트 뿐만 아니라, 각 컨테이너 별로 별도의 환경을 제공함으로써 충돌이 발생하지 않아야 한다.



 리눅스 커널에서는 `namespaces`를 통해 이를 가능하게 한다.

* **mnt** : 독립적으로 파일 시스템을 구성할 수 있도록 함
* **pid** : 독립적인 프로세스 번호가 부여되도록 함
* **net** : 포트, 바인딩을 독립적으로 사용하도록 함
* **ipc** : 프로세스의 독립적인 통로를 부여함
* **uts** : 별도의 hostname을 부여함
* **uid** : 별도의 사용자 관리를 가능하도록 함



# Docker file

 도커의 컨테이너는 LXC와 달리 각 컨테이너의 정보를 `Docker file`로 관리 할 수 있는 장점이 있다. 또한 컨테이너에 실행 파일 뿐 아니라, 실행 환경도 함께 배포가 가능하다. 이는 호스트의 실행 환경에 따른 프로그램 동작 여부에 대한 문제를 줄여 줄 수 있으며, 빠르게 구현이 가능하다는 장점을 동반한다. 도커 컨테이너의 기반이 되는 이미지를 빌드를 위해 Docker file을 참조하여 이미지를 빌드하며, 간단한 예시는 다음과 같다.

  

```dockerfile
FROM ubuntu:16.04
COPY hello /usr/local/bin
RUN chmod +x /usr/local/bin/hello
CMD ["hello"]
```

* **FROM** : 도커 이미지를 지정한다.
* **COPY** : 현재 로컬 호스트에서 복사하고자 하는 파일을 복사한다.
* **RUN** : 컨테이너의 내부에 필요한 동작들을 수행 할 수 있다.
* **CMD** : 컨테이너 실행 시 실행할 명령을 지정할 수 있다.

  

# Moby

 2017년 도커 컨퍼런스에서 Moby  프로젝트에 대한 발표가 있었다. Moby 프로젝트가 등장하면서 도커 CE/EE의 관계를 다음과 같이 정의하였다.

|이름|역할|
|:----:|:-:|
|테스트1|컴포넌트|
|Docker CE|Moby + 컴포넌트를 조합한 무료 버전|
|Docker EE|상용 버전|
